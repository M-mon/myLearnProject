参考：http://c.biancheng.net/design_pattern/

面向对象应该遵守的原则：

开闭原则（Open Closed Principle，OCP）：
软件实体应当对扩展开放，对修改关闭。



里氏替换原则（Liskov Substitution Principle，LSP）：
继承必须确保超类所拥有的性质在子类中仍然成立。
里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。
里氏替换原则通俗来讲就是：类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。


依赖倒置原则（Dependence Inversion Principle，DIP）：
高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。
核心思想是：要面向接口编程，不要面向实现编程。
依赖倒置原则的主要作用如下：
    **依赖倒置原则可以降低类间的耦合性。
    **依赖倒置原则可以提高系统的稳定性。
    **依赖倒置原则可以减少并行开发引起的风险。
    **依赖倒置原则可以提高代码的可读性和可维护性。
遵循以下4点，就能在项目中满足这个规则。
    **每个类尽量提供接口或抽象类，或者两者都具备。
    **变量的声明类型尽量是接口或者是抽象类。
    **任何类都不应该从具体类派生。
    **使用继承时尽量遵循里氏替换原则。


单一职责原则（Single Responsibility Principle，SRP）又称单一功能原则。
这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。
该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：
    **一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；
    **当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。
遵循单一职责原则将有以下优点。
    **降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。
    **提高类的可读性。复杂性降低，自然其可读性会提高。
    **提高系统的可维护性。可读性提高，那自然更容易维护了。
    **变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。



接口隔离原则（Interface Segregation Principle，ISP）
要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。
定义：客户端不应该被迫依赖于它不使用的方法。或者，一个类对另一个类的依赖应该建立在最小的接口上。
以上两个定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。
    **将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。
    **接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。
    **如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。
    **使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。
    **能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。
在具体应用接口隔离原则时，应该根据以下几个规则来衡量。
    **接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。
    **为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。
    **了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同，需深入了解业务逻辑。
    **提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。



接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：
    **单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
    **单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。


迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)
定义：只与你的直接朋友交谈，不跟“陌生人”说话。
含义：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。
目的：降低类之间的耦合度，提高模块的相对独立性。
迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。
    **降低了类之间的耦合度，提高了模块的相对独立性。
    **由于亲合度降低，从而提高了类的可复用率和系统的扩展性。
过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
强调以下两点：
    **从依赖者的角度来说，只依赖应该依赖的对象。
    **从被依赖者的角度说，只暴露应该暴露的方法。
要注意以下 6 点。
    **在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
    **在类的结构设计上，尽量降低类成员的访问权限。
    **在类的设计上，优先考虑将一个类设置成不变类。
    **在对其他类的引用上，将引用其他对象的次数降到最低。
    **不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
    **谨慎使用序列化（Serializable）功能。



合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）
要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。
如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。
通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。
    **继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。
    **子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。
    **它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。
采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。
    **它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。
    **新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。
    **复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。
合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。



7条原则简单归纳：
开闭原则：能有良好的扩展性，尽量不修改原有功能代码。
里氏替换原则：子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
依赖倒置原则：面向接口编程，不要面向实现编程。尽可能使用上层类（父类、接口）代替下层类（子类、实现类）。
单一职责原则：使类的功能划分更细腻，更加模块化。要有一种，看见类名，就能猜到会有什么功能。
接口隔离原则：根据一定的规律进行接口的划分，使接口的功能定义更明确，使出现的问题更类似更集中。
      **单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
      **单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。
迪米特法则：减少类与类的直接接触，尽量用最少的类接触更多的类。
合成复用原则：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。


不修改，要扩展（开闭原则）。
父类是老大，他说了算（里氏替换原则）。
上层能见光，下层不见光（依赖倒置原则）。
细分有必要（单一职责原则、接口隔离原则），接触没必要（迪米特法则）。
只要最少类，即可找到你（迪米特法则）。
关联修改容易，继承修改难，若怕有修改，请先试关联（合成复用原则）。

