在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。
例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；
医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，
划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。

这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；
还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。

这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。
访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。

访问者（Visitor）模式的定义：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，
为数据结构中的每个元素提供多种访问方式。它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。

访问者（Visitor）模式是一种对象行为型模式，其主要优点如下。
    **扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。
    **复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。
    **灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。
    **符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。

访问者（Visitor）模式的主要缺点如下。
    **增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。
    **破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。
    **违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。

访问者（Visitor）模式实现的关键是如何将作用于元素的操作分离出来封装成独立的类。

访问者模式包含以下主要角色。
    **抽象访问者（Visitor）角色：定义一个访问具体元素的接口，为每个具体元素类对应一个访问操作 visit() ，该操作中的参数类型标识了被访问的具体元素。
    **具体访问者（ConcreteVisitor）角色：实现抽象访问者角色中声明的各个访问操作，确定访问者访问一个元素时该做什么。
    **抽象元素（Element）角色：声明一个包含接受操作 accept() 的接口，被接受的访问者对象作为 accept() 方法的参数。
    **具体元素（ConcreteElement）角色：实现抽象元素角色提供的 accept() 操作，其方法体通常都是 visitor.visit(this) ，另外具体元素中可能还包含本身业务逻辑的相关操作。
    **对象结构（Object Structure）角色：是一个包含元素角色的容器，提供让访问者对象遍历容器中的所有元素的方法，通常由 List、Set、Map 等聚合类实现。


【例1】VisitorProducer.java
利用“访问者（Visitor）模式”模拟艺术公司与造币公司的功能。
分析：艺术公司利用“铜”可以设计出铜像，利用“纸”可以画出图画；
造币公司利用“铜”可以印出铜币，利用“纸”可以印出纸币。
对“铜”和“纸”这两种元素，两个公司的处理方法不同，所以该实例用访问者模式来实现比较适合。

首先，定义一个公司（Company）接口，它是抽象访问者，提供了两个根据纸（Paper）或铜（Cuprum）这两种元素创建作品的方法；
再定义艺术公司（ArtCompany）类和造币公司（Mint）类，它们是具体访问者，实现了父接口的方法；
然后，定义一个材料（Material）接口，它是抽象元素，提供了 accept（Company visitor）方法来接受访问者（Company）对象访问；
再定义纸（Paper）类和铜（Cuprum）类，它们是具体元素类，实现了父接口中的方法；
最后，定义一个材料集（SetMaterial）类，它是对象结构角色，拥有保存所有元素的容器 List，并提供让访问者对象遍历容器中的所有元素的 accept（Company visitor）方法；
客户类设计成窗体程序，它提供材料集（SetMaterial）对象供访问者（Company）对象访问，实现了 ItemListener 接口，处理用户的事件请求。


通常在以下情况可以考虑使用访问者（Visitor）模式。
    **对象结构相对稳定，但其操作算法经常变化的程序。
    **对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。
    **对象结构包含很多类型的对象，希望对这些对象实施一些依赖于其具体类型的操作。

访问者（Visitor）模式是使用频率较高的一种设计模式，它常常同以下两种设计模式联用。
(1)与“迭代器模式”联用。
因为访问者模式中的“对象结构”是一个包含元素角色的容器，当访问者遍历容器中的所有元素时，常常要用迭代器。
如【例1】中的对象结构是用 List 实现的，它通过 List 对象的 Itemtor() 方法获取迭代器。
如果对象结构中的聚合类没有提供迭代器，也可以用迭代器模式自定义一个。

(2)访问者（Visitor）模式同“组合模式”联用。
因为访问者（Visitor）模式中的“元素对象”可能是叶子对象或者是容器对象，如果元素对象包含容器对象，就必须用到组合模式。

理解：  数据实体需接收（accept方法）访问者；
        接收后，再（在accept方法体内）把数据实体自身传递给访问者（调用访问者的具体访问方法，一般是visitor.visit(this)）；
        以上是数据实体和访问者之间的关系，但由于数据实体的类型和数量是不明确的，所以需要保存各种类型的数据实体，引入对象结构（Object Structure）角色；
        对象结构（Object Structure）角色，形象的说，就像是一个资料贩子，保有各种资料（数据实体），访问者就像是买家，
        买家过来交易（接收访问者参数），资料贩子告诉他我有什么资料（循环、迭代数据实体），买家拿到资料后（accept方法和visit(this)），
        资料贩子的这次访问的职责实际就结束了，其等待下一个买家的到来。
        通过以上说明，可以更清晰地联想到，多方需要使用（买）相同类型的数据实体（资料）时，就建议使用访问者模式。